#### 1. 执行上下文
- 全局执行上下文
  - 创建时间：js 引擎运行代码的时候，第一个被创建的执行上下文。
  - 创建时会做什么？
    - 创建一个全局对象【window/global】
    - 创建this对象
    - 给变量和安徽念书分配内存
    - 给变量赋默认值undefined，把函数声明放进内存。
- 函数执行上下文
  - 创建时间：函数被调用的时候
  - 创建时会做什么？
    - 创建一个atguments 对象
    - 创建this对象
    - 给变量和函数分配内存
    - 给变量赋默认值undefined，把所有函数声明放进内存。
#### 2. 变量提升：
- js 并不是严格自上而下执行的语言。
- 会将当前作用域的所有变量的声明提升到程序的顶部。
- js 会有编译 和 执行 两个阶段， 会搜集所有的变量声明并提前 声明变量。
- 函数声明和其他声明一起出现的时候，以函数为准，函数声明高于一切。
- 多个函数声明的时候，由最后面的函数声明来替代前面的。
- let 也具有变量提升的概念，但是它具有一个临时性死区。从当前作用域开始，到 let a = 5为止，都是a变量的临时性死区，不能使用它。
- 即使函数g()没有提前激活，也可以被前面的函数 f()（在同一作用域内）调用 - 只要遵守以下规则：f() 必须在声明 g() 之后调用
```
const f = () => g();
const g = () => 123;

// g() 声明后调用 f()：
assert.equal(f(), 123);
```
- 类声明不会提前声明
#### 4. var、let、const区别
- var：
  - 变量提升，并且初始化为 undefined
  - 会覆盖/污染 当前 作用域的变量（全局作用域声明时，属于顶层对象的属性，在浏览器环境下属于window属性）
- let：
  - 变量提升，但会形成暂时性死区
  - 并不会覆盖 window 上的变量。（var 声明的全局环境的变量，会挂载在 window 上）
  - 循环中形成新的块级绑定（for 循环的时候，每次都会创建一个新的绑定）
- const：
  - 保存的常量，基本数据类型的不可修改，对象可以修改。（对象保存在堆里，基本数据类型保存在栈里）
#### 5. js 的数据类型
- 
#### 6. js 的垃圾回收机制
#### 2. 作用域：
- 作用域：变量可以访问之处。
- 分类：
  - 全局作用域
  - 函数作用域
  - 块级作用域：let 、const 特有的
- 作用域链：每逢当前执行上下文中找不到所需变量，Javascript引擎就向上逐级查找，这个处理过程就是作用域链。
- 子级执行上下文可以引用父级执行上下文中声明的变量，但反过来就不行。
- 函数中创建的变量仅局部有效，一旦函数执行上下文从调用栈弹出，这些变量就访问不到了（通常如此，闭包不是）
#### 3.闭包：
- 基本概念：
- 特性：
- 使用场景：
- 弊端：
#### 4. this：
- 基本概念：
- call：
  - 功能：
  - 实现：
- apply：
  - 功能：
  - 实现：
- bind：
  - 功能：
  - 实现1（用call/apply）：
  - 实现2（用js）：
#### 5. 箭头函数：
- 实现： （）=> {}
- 特点：
#### 7.
