#### 1. 执行上下文
- 全局执行上下文
  - 创建时间：js 引擎运行代码的时候，第一个被创建的执行上下文。
  - 创建时会做什么？
    - 创建一个全局对象【window/global】
    - 创建this对象
    - 给变量和安徽念书分配内存
    - 给变量赋默认值undefined，把函数声明放进内存。
- 函数执行上下文
  - 创建时间：函数被调用的时候
  - 创建时会做什么？
    - 创建一个atguments 对象
    - 创建this对象
    - 给变量和函数分配内存
    - 给变量赋默认值undefined，把所有函数声明放进内存。
#### 2. 变量提升：
- js 并不是严格自上而下执行的语言。
- 会将当前作用域的所有变量的声明提升到程序的顶部。
- js 会有编译 和 执行 两个阶段， 会搜集所有的变量声明并提前 声明变量。
- 函数声明和其他声明一起出现的时候，以函数为准，函数声明高于一切。
- 多个函数声明的时候，由最后面的函数声明来替代前面的。
- let 也具有变量提升的概念，但是它具有一个临时性死区。从当前作用域开始，到 let a = 5为止，都是a变量的临时性死区，不能使用它。
- 即使函数g()没有提前激活，也可以被前面的函数 f()（在同一作用域内）调用 - 只要遵守以下规则：f() 必须在声明 g() 之后调用
```
const f = () => g();
const g = () => 123;

// g() 声明后调用 f()：
assert.equal(f(), 123);
```
- 类声明不会提前声明
#### 2. 作用域：
- 作用域：变量可以访问之处。
- 分类：
  - 全局作用域
  - 函数作用域
  - 块级作用域：let 、const 特有的
- 作用域链：每逢当前执行上下文中找不到所需变量，Javascript引擎就向上逐级查找，这个处理过程就是作用域链。
- 子级执行上下文可以引用父级执行上下文中声明的变量，但反过来就不行。
- 函数中创建的变量仅局部有效，一旦函数执行上下文从调用栈弹出，这些变量就访问不到了（通常如此，闭包不是）
#### 3.闭包：
- 
#### 4. var、let、const：
- 
#### 4. this：
- 
